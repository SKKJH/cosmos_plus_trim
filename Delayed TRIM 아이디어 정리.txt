Delayed TRIM 아이디어 정리

서론
1) Host 파일 삭제를 디바이스가 모름 -> Overwrite 되기 전까지 GC Cost 증가
2) TRIM은 Flash에 Invalid Page 정보 전달
3) TRIM 처리 동안 I/O 요청 응답 불가능
4) 추가로 TRIM 오버헤드가 큼 
	4-1) Write Buffer 처리
	4-2) Mapping Table 처리
5) 이러한 이유로 F2FS는 Device IDLE 할 때 까지 TRIM(Discard) 지연
	5-1) Device IDLE Time이 주어지지 않으면 GC Copy 증가
6) TRIM 무시하는 Device도 존재
7) TRIM 명령을 동기적으로 보내되 디바이스가 내부 정보 바탕으로 처리하도록 제안

본론
1) Delayed TRIM - All
	1) 디바이스 내부에 Trim Buffer 두고, Trim 요청 저장
		1-1) TRIM Request를 Range 크기 순으로 정렬
	2) 디바이스가 IDLE 해지면 TRIM 처리
	3) TRIM 지연되는 동안 Write 관리
		3-1) Write Bitmap 추가
		3-2) Trim이 지연되는동안 발생한 Write Page 기록
	4) 디바이스가 IDLE 해지면 Trim buffer 순회하며 Trim 반영
		4-1) Write Bitmap 보고 겹치는 페이지는 반영안함
		4-2) 중간에 I/O 오면 I/O 우선 반영
	5) GC 수행 전에 지연된 TRIM 모두 반영
		5-1) Trim 반영하고 Invalid Block 선정
		5-2) GC 전에 모든 TRIM 반영하면 오버헤드 커질 수 있으므로, 부분 Delayed TRIM 추가 제안

2) Delayed TRIM - Adoptive
	1) Rough Adoptive
		1-1) 기본적인 동작은 유사, GC에 의한 Call에서만 차이
		1-2) GC 수행 전 최대 Invalid Page Count 확인
		1-3) Invalid Page Count 최대값의 절반 이상 -> Trim 반영 X
		1-4) Invalid Page Count 최대값의 절반 이하 -> Trim 반영 O
		1-5) 이후에 Invalid Block 선정
	2) Smooth Adoptive
		2-1) Invalid Page Count 1/3 이하 -> 모든 Trim 반영
		2-2) Invalid Page Count 2/3 이하 -> 절반 Trim 반영
		2-3) Invalid Page Count 2/3 이상 -> Trim 반영 X

실험
1) Conv Trim vs Delayed Trim -All 
	1-1) WAF
	1-2) Latency
2) Delayed Trim -All vs Delayed Trim - Adoptive 
	2-1) WAF
	2-2) Latency
	2-3) GC 감소 반영 (Adoptive)
3) F2FS
	3-1) Trim 지연 없는 Delayed Trim vs 지연 있는 Conv Trim 